# GitHub Copilot Adaptations for AutoSDLC
# Optimizations specifically for GitHub Copilot's capabilities and limitations

copilot_mode:
  enabled: true
  version: "1.0"
  
  # State Management
  state_files:
    primary: ".AutoSDLC/copilot-state.md"
    action_plan: ".AutoSDLC/action-plan.md"
    context_anchors: ".AutoSDLC/context-anchors.md"
    behavior_triggers: ".AutoSDLC/behavior-triggers.md"
    
  # Word/Token Limits (optimized for Copilot's context window)
  word_limits:
    copilot_state: 200
    action_plan: 300
    context_anchors: 300
    behavior_triggers: 250
    total_short_term_budget: 1050
    
  # Long-term memory (load on-demand)
  long_term_limits:
    semantic_knowledge_base: 2000  # ~50KB
    semantic_glossary: 500
    episodic_per_agent: 1500
    procedural_agent_skills: 2000
    procedural_user_preferences: 1500
    
  # Update Triggers
  auto_update_on:
    - "task_complete"
    - "test_pass"
    - "code_commit"
    - "gate_transition"
    - "blocker_encountered"
    - "session_end"
    - "recording_start"
    - "recording_stop"
    
  # Autonomous Behaviors (what Copilot can do without asking)
  autonomous_actions:
    - "write_code"
    - "write_tests"
    - "run_tests"
    - "fix_test_failures"
    - "update_documentation"
    - "refactor_code"
    - "add_error_handling"
    - "update_state_files"
    - "capture_session_recording"
    
  # Requires Approval (what Copilot must ask about)
  requires_approval:
    - "gate_transition"
    - "architecture_change"
    - "tech_stack_change"
    - "skip_quality_gate"
    - "delete_code"
    - "security_changes"
    - "production_deployment"
    
  # Proactive Prompts (what Copilot should say automatically)
  auto_prompts:
    on_conversation_start: "Reading state files and resuming work..."
    on_task_complete: "Task complete. Updating state and moving to next task..."
    on_tests_pass: "All tests passing. Checking off action plan item..."
    on_continue: "Continuing with next action from plan..."
    on_blocker: "Blocker encountered. Documenting and awaiting guidance..."
    on_recording_request: "Asking user to choose recording scope (future only or full session)..."
    on_recording_started: "Session recording enabled. Capturing interactions..."
    on_recording_stopped: "Session recording stopped. File saved to .AutoSDLC/memory/sessions/"

# Session Recording Configuration

session_recording:
  enabled: true
  
  # Storage
  storage:
    directory: ".AutoSDLC/memory/sessions/"
    template: ".AutoSDLC-framework/templates/session-context/session-recording.template.md"
    filename_format: "YYYY-MM-DD_HH-MM_task-name.md"
    
  # Privacy
  privacy:
    gitignored: true
    local_only: true
    warn_before_sharing: true
    
  # Recording modes
  modes:
    future_only:
      description: "Capture from enable point forward"
      default: false
      privacy_level: "high"
      
    full_session:
      description: "Capture entire conversation from start"
      default: false
      privacy_level: "medium"
      requires_explicit_consent: true
      
  # User prompts
  prompts:
    ask_scope:
      enabled: true
      message: |
        ‚úÖ Starting session recording
        
        üìù What would you like to record?
        
        [1] üìç Future messages only
            ‚îî‚îÄ> Records from this point forward
            ‚îî‚îÄ> More privacy-conscious
        
        [2] üìö Full session (include previous)
            ‚îî‚îÄ> Captures entire conversation from start
            ‚îî‚îÄ> Complete context for education
        
        Please choose [1] or [2]:
    
    started_future:
      message: |
        ‚úÖ Recording enabled (Future only)
        üìù File: .AutoSDLC/memory/sessions/{filename}
        ‚èπÔ∏è  To stop: 'stop recording'
    
    started_full:
      message: |
        ‚úÖ Recording enabled (FULL SESSION)
        üìù File: .AutoSDLC/memory/sessions/{filename}
        üìç Recording from: Session start (captured {N} previous messages)
        ‚ö†Ô∏è  Note: All previous messages included
        ‚èπÔ∏è  To stop: 'stop recording'
    
    stopped:
      message: |
        ‚èπÔ∏è Session recording stopped
        üíæ Saved: .AutoSDLC/memory/sessions/{filename}
        üìä Captured: {N} messages, {N} words
        ‚ö†Ô∏è  Reminder: Review for sensitive info before sharing
        ‚úÖ Ready to share for educational purposes
  
  # Capture settings
  capture:
    include_timestamps: true
    include_agent_names: true
    capture_code_changes: true
    capture_decisions: true
    capture_metrics: true
    
  # Content to capture
  content:
    - "user_messages"
    - "agent_responses"
    - "key_decisions"
    - "code_changes"
    - "learnings"
    - "session_metrics"

# Memory Loading Strategy for Copilot

memory_loading:
  
  # Always load (automatic - part of instructions)
  always_load:
    - ".AutoSDLC/copilot-state.md"
    - ".AutoSDLC/action-plan.md"
    
  # Load at session start
  session_start:
    - ".AutoSDLC/copilot-state.md"
    - ".AutoSDLC/memory/semantic/knowledge-base.md"
    - ".AutoSDLC/memory/episodic/{current-agent}.md"
    
  # Load on-demand (when needed)
  on_demand:
    context_anchors:
      when: "User asks 'what am I working on?' or context unclear"
    
    behavior_triggers:
      when: "Uncertain what to do next or how to behave"
    
    glossary:
      when: "Domain terminology confusion"
    
    agent_skills:
      when: "Doing a task for the first time or need procedure reminder"
    
    user_preferences:
      when: "User gives feedback about style or approach"
    
    other_agent_episodic:
      when: "Collaborating with another agent"

# Aggressive Memory Offloading for Token Management

memory_management:
  strategy: "aggressive_offload"
  
  checkpoint_triggers:
    gate_completion: true  # Always checkpoint after gate
    message_interval: 15   # Every 15 AI messages
    token_threshold: 0.25  # At 25% of context limit (auto-detect if possible)
    before_major_decision: true
    
  checkpoint_procedure:
    1_summarize:
      - "Summarize conversation since last checkpoint (200-500 words)"
      - "Focus on: decisions made, actions taken, blockers encountered"
    
    2_extract_to_semantic:
      - "Extract facts, decisions, architecture to knowledge-base.md"
      - "Extract JIRA workflow changes to jira-workflow.md"
      - "Update project glossary if new terms introduced"
    
    3_extract_to_episodic:
      - "Update current agent's episodic memory with session actions"
      - "Include: what was done, why, outcomes, lessons"
    
    4_extract_to_procedural:
      - "Update skills/preferences if new patterns learned"
      - "Document effective techniques that worked"
    
    5_update_state:
      - "Update copilot-state.md or status.yaml with current position"
      - "Update action-plan.md with next steps"
    
    6_truncate_context:
      - "Clear conversation history except last 5 messages"
      - "Mark checkpoint with: '‚úÖ Memory Checkpoint #{number} saved at {timestamp}'"
    
    7_verify:
      - "Read back knowledge-base.md last 10 lines to confirm"
      - "Confirm checkpoint number incremented"

  memory_compression:
    enabled: true
    compression_triggers:
      - "Weekly compression of episodic memories older than 7 days"
      - "Monthly compression of episodic memories older than 30 days"
    
    compression_process:
      - "Replace daily episodic entries with weekly summary"
      - "Keep: key decisions, major learnings, critical events"
      - "Archive: detailed message-by-message logs to .AutoSDLC/memory/archive/"
      - "Format: YYYY-MM-weekly-summary.md or YYYY-MM-monthly-summary.md"

  context_limit_detection:
    auto_detect: true  # Try to detect token usage automatically
    fallback_threshold: 0.25  # Use 25% if auto-detect unavailable
    warning_levels:
      - threshold: 0.25
        action: "Trigger memory checkpoint"
      - threshold: 0.50
        action: "Force checkpoint + aggressive compression"
      - threshold: 0.75
        action: "Emergency checkpoint + warn user"

# Optimization Strategies

optimization:
  
  # Keep short-term memory compact
  short_term:
    - "Use abbreviations where clear"
    - "Remove completed items from checklists periodically"
    - "Keep 'Recent Changes' to last 3 only"
    - "Use bullet points instead of paragraphs"
    
  # Lazy-load long-term memory
  long_term:
    - "Only load semantic memory when architecture questions arise"
    - "Only load episodic memory at session start and end"
    - "Only load procedural memory when executing procedures"
    - "Cache loaded memories within session"
  
  # Progressive disclosure
  disclosure:
    - "Start with copilot-state.md (essential context)"
    - "Add action-plan.md if user wants to continue"
    - "Add semantic/episodic only when needed for decision"
    - "Load procedural only when executing specific procedures"

# Copilot-Specific Behaviors

behaviors:
  
  # How to handle Copilot's limitations
  limitations:
    
    statelessness:
      strategy: "Rely heavily on copilot-state.md - it's the memory"
      mitigation: "Always read copilot-state.md first in every interaction"
      
    smaller_context:
      strategy: "Use compact formats and load selectively"
      mitigation: "Prioritize recent/relevant info over completeness"
      
    less_proactive:
      strategy: "Rely on behavior-triggers.md to know when to act"
      mitigation: "User may need to explicitly say 'continue' or 'status'"
      
    explicit_loading:
      strategy: "User may need to use @workspace to load files"
      mitigation: "Instructions remind user to use @workspace for long-term memory"
  
  # Enhanced prompting for Copilot
  prompt_patterns:
    
    session_start:
      user_should_say: "@workspace Check .AutoSDLC/copilot-state.md and continue"
      copilot_does: "Loads state, shows current context, asks if continuing"
      
    continue_work:
      user_should_say: "continue or keep going"
      copilot_does: "Executes next action-plan item automatically"
      
    check_status:
      user_should_say: "status or where are we"
      copilot_does: "Reads state and action-plan, shows summary"
      
    load_memory:
      user_should_say: "@workspace Load memory for [topic]"
      copilot_does: "Loads relevant semantic/episodic/procedural memory"

# Integration with Core AutoSDLC

AutoSDLC_integration:
  
  # Works alongside existing structure
  compatibility:
    - "All core AutoSDLC YAML configs remain unchanged"
    - "ORCHESTRATOR.md remains primary instruction source"
    - "Memory system is universal (works for Claude, Cursor, Copilot)"
    - "Copilot files are additions, not replacements"
  
  # Entry points
  entry_points:
    copilot: ".github/copilot-instructions.md"
    claude: "claude.md ‚Üí ORCHESTRATOR.md"
    cursor: ".cursorrules ‚Üí ORCHESTRATOR.md"
    
  # All tools use same memory
  universal_memory:
    - ".AutoSDLC/memory/ is tool-agnostic"
    - "All tools read/write same memory files"
    - "No tool-specific memory formats"

# Usage Guidelines

usage:
  
  for_users:
    - "Start sessions with '@workspace Check copilot-state.md'"
    - "Say 'continue' to have Copilot work autonomously"
    - "Say 'status' to see where you are"
    - "Use @workspace to load long-term memory when needed"
    
  for_copilot:
    - "ALWAYS read copilot-state.md first"
    - "Follow action-plan.md for autonomous work"
    - "Update state files after significant actions"
    - "Use behavior-triggers.md to know when to act"
    - "Load long-term memory only when needed"

---
# This configuration optimizes AutoSDLC for GitHub Copilot
# While maintaining compatibility with Claude and Cursor
# Last Updated: {LAST_UPDATE_DATE}
